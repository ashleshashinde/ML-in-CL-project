#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri May  3 17:07:40 2019

@author: ashleshashinde
"""

# Linear SVC with TF-IDF

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.pipeline import Pipeline
from sklearn.svm import LinearSVC
from sklearn.metrics import accuracy_score
import re
import nltk
from nltk.stem import WordNetLemmatizer
from nltk.corpus import stopwords
nltk.download('stopwords')
nltk.download('wordnet')

import warnings
warnings.simplefilter("ignore")

#Reading the csv files
train_lyrics = pd.read_csv("train_lyrics_1000.csv")
valid_lyrics = pd.read_csv("valid_lyrics_200.csv")




#preprocess_lyric fucntion to clean the lyric file.
def preprocess_lyric(given_lyric):
    lyric = given_lyric
    lyric = re.sub('[^a-zA-Z]', ' ',lyric)
    lyric = lyric.lower()
    lyric = lyric.split()
    lemmatizer = WordNetLemmatizer()
    lyric = [lemmatizer.lemmatize(w) for w in lyric if not w in set(stopwords.words('english'))]
    return (' '.join(lyric))


#Cleaning the train and valid data and adding it into respective data frames

print("Cleaning the train set............")
train_lyrics['Cleaned_Lyric'] = train_lyrics["lyrics"].apply(lambda x :preprocess_lyric(x))
train_lyrics.to_csv("mood_cleaned_lyrics.tsv", sep='\t', index = False)
print("Cleaned train lyrics loaded to tsv file............")
valid_lyrics['Cleaned_Lyric'] = valid_lyrics["lyrics"].apply(lambda x :preprocess_lyric(x))




#Best Model:


y_train = train_lyrics["mood"]
y_test = valid_lyrics["mood"]


svc = LinearSVC(
    C=1.0,
    class_weight='balanced',
    dual=True,
    fit_intercept=True,
    intercept_scaling=1,
    loss='squared_hinge',
    max_iter=1000,
    multi_class='ovr',
    penalty='l2',
    random_state=0,
    tol=1e-05, 
    verbose=2
)

tfidf = TfidfVectorizer(
    input='content',
    encoding='utf-8',
    decode_error='replace',
    strip_accents='unicode',
    lowercase=True,
    preprocessor=None,
    tokenizer=None,
    stop_words='english',
    ngram_range=(1, 3),
    analyzer='word',
    max_df=1.0,
    min_df=2,
    max_features=None,
    vocabulary=None,
    binary=False
)

pipeline = Pipeline([
    ('tfidf', tfidf),
    ('svc', svc),
])


pipeline.fit(train_lyrics['Cleaned_Lyric'],y_train)
y_test_pred = pipeline.predict(valid_lyrics['Cleaned_Lyric'])

pip_score = accuracy_score(y_test,y_test_pred)
print("Linear SVC score", pip_score*100,"%")




print("------------DYNAMIC LEARNING STARTS HERE-------------------")
##DYNAMIC LEARNING##
#Taking the feedback file from flask :

import csv
import pandas as pd


feedback_dict={}
new_dict={}
column_list = ['title', 'artist', 'lyrics','genre', 'mood']


#Max Voting Algorithm
def max_voting(feedback_dict):
    for key in feedback_dict:
        value=feedback_dict[key]
        happy=0
        sad=0
        for feedback in value:
                mood=feedback[3] 
                score=feedback[5]
                if mood=="happy" and score == '0':
                    happy+=1
                elif mood=="happy" and score == '1':
                    sad+=1
                elif mood=="sad" and score == '1':
                    happy+=1
                elif mood=="sad" and score == '0':
                    sad+=1
        if happy > sad:
             new_dict[key]=(feedback[0],feedback[1],feedback[2],feedback[4],"happy")
        else:
             new_dict[key]=(feedback[0],feedback[1],feedback[2],feedback[4],"sad")
    return(new_dict)

 
#Reading the user feedback generated by flask(feedback.csv)
print("--------------------Takes the feedback file---------------------------")
with open('feedback.csv','r') as file:
    reader = csv.reader(file)
    for rows in reader:
        key= rows[1]+" "+rows[2]
        if key in feedback_dict:
            feedback_dict[key].append((rows[1],rows[2],rows[3],rows[4],rows[5],rows[7]))
        else:
            feedback_dict[key] = [(rows[1],rows[2],rows[3],rows[4],rows[5],rows[7])]




            
            
print("---------------Max Voting performed---------------")
new_dict=max_voting(feedback_dict)
new_df = pd.DataFrame.from_dict(new_dict, orient = 'index',columns=column_list)
retrain_df = new_df
retrain_df["Key"]=retrain_df.index
retrain_df=retrain_df.reset_index()
retrain_df=retrain_df.drop(columns=['index'])



#Updating the training data (cleaned) according to feedback

retrain_df['Cleaned_Lyric'] = retrain_df["lyrics"].apply(lambda x :preprocess_lyric(x))
train_lyrics['Key'] = train_lyrics[['title', 'artist']].apply(lambda x: ' '.join(x), axis=1)

for index, row in retrain_df.iterrows():
    key=row['Key']
    found = train_lyrics[train_lyrics['Key'].str.contains(row["Key"])]
    if found.empty:
        train_lyrics=train_lyrics.append(row)
    else:
        train_lyrics.at[found.index,'mood']=row['mood']


#Re-trainining the updated train information to our best model
print("------------------Retraining the model---------------------")
from sklearn.externals import joblib

def retrain(new_train_df):
    pipeline.fit(new_train_df['Cleaned_Lyric'],new_train_df["mood"])
    y_test_predic = pipeline.predict(valid_lyrics['Cleaned_Lyric'])
    retrain_pip_score = accuracy_score(valid_lyrics["mood"],y_test_predic)
    print("Linear SVC score", retrain_pip_score*100,"%")
    joblib.dump(pipeline, 'pipeline_mood.pkl')

    
#Calling the function would generate the pickled retrained-model based on Dynamic learning: 
retrain(train_lyrics)   
print("-------------Pickeled file generated---------------------")   
    
    

        
        
        
        
